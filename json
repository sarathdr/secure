import io.vertx.core.Future;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.sqlclient.Row;
import io.vertx.sqlclient.RowSet;
import io.vertx.sqlclient.Tuple;
import io.vertx.sqlclient.impl.RowImpl;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

import com.flexnet.lm.binary.PublisherIdentityRecord;
import com.flexnet.lm.signer.Signer;
import com.flexnet.lm.signer.SignerFactory;
import io.vertx.core.buffer.Buffer;
import org.junit.jupiter.api.extension.ExtendWith;
import java.util.Iterator;

@ExtendWith(MockitoExtension.class)
public class DbSignatureValidatorTest {

    @Mock
    private JDBCPool jdbcPool;

    @Mock
    private RowSet<Row> rowSet;

    @Mock
    private Row row;

    @Mock
    private Signer signer;

    @Mock
    private PublisherIdentityRecord identity;

    private DbSignatureValidator dbSignatureValidator;
    private final byte[] signature = new byte[]{1, 2, 3};
    private final byte[] data = new byte[]{4, 5, 6};

    @BeforeEach
    public void setup() {
        dbSignatureValidator = DbSignatureValidator.create(jdbcPool);
    }

    @Test
    public void testCreate() {
        assertNotNull(dbSignatureValidator);
    }

    @Test
    public void testValidateSignatureNoRows() {
        when(jdbcPool.preparedQuery(anyString())).thenReturn(Future.succeededFuture(rowSet));
        when(rowSet.size()).thenReturn(0);

        Future<Boolean> result = dbSignatureValidator.validateSignature("tenantId", "instanceId", signature, data);

        assertTrue(result.succeeded());
        assertFalse(result.result());
    }

    @Test
    public void testValidateSignatureSuccess() throws Exception {
        when(jdbcPool.preparedQuery(anyString())).thenReturn(Future.succeededFuture(rowSet));
        when(rowSet.size()).thenReturn(1);
        when(rowSet.iterator()).thenReturn(new Iterator<Row>() {
            private boolean hasNext = true;

            @Override
            public boolean hasNext() {
                return hasNext;
            }

            @Override
            public Row next() {
                hasNext = false;
                return row;
            }
        });
        when(row.getBuffer(DbSignatureValidator.IDENTITY_COLUMN_NAME)).thenReturn(Buffer.buffer(new byte[]{1, 2, 3}));
        when(identity.parseAll(any())).thenReturn(identity);
        when(identity.parse()).thenReturn(identity);
        when(SignerFactory.getInstance(any(), any())).thenReturn(signer);
        when(signer.isSignatureValid(any())).thenReturn(true);

        Future<Boolean> result = dbSignatureValidator.validateSignature("tenantId", "instanceId", signature, data);

        assertTrue(result.succeeded());
        assertTrue(result.result());
    }

    @Test
    public void testValidateSignatureFailureDuringProcessing() throws Exception {
        when(jdbcPool.preparedQuery(anyString())).thenReturn(Future.succeededFuture(rowSet));
        when(rowSet.size()).thenReturn(1);
        when(rowSet.iterator()).thenReturn(new Iterator<Row>() {
            private boolean hasNext = true;

            @Override
            public boolean hasNext() {
                return hasNext;
            }

            @Override
            public Row next() {
                hasNext = false;
                return row;
            }
        });
        when(row.getBuffer(DbSignatureValidator.IDENTITY_COLUMN_NAME)).thenReturn(Buffer.buffer(new byte[]{1, 2, 3}));
        when(identity.parseAll(any())).thenThrow(new RuntimeException("Test exception"));

        Future<Boolean> result = dbSignatureValidator.validateSignature("tenantId", "instanceId", signature, data);

        assertTrue(result.failed());
        assertEquals("Test exception", result.cause().getMessage());
    }
}

import com.rabbitmq.client.BuiltinExchangeType;
import com.usage.common.AppConfig;
import com.usage.verticles.RabbitMQConsumerVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.rabbitmq.RabbitMQClient;
import io.vertx.rabbitmq.RabbitMQOptions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.jupiter.api.extension.ExtendWith;

import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class RabbitMQServiceTest {

    @Mock
    private Vertx vertx;

    @Mock
    private RabbitMQClient rabbitMQClient;

    @Mock
    private JsonObject config;

    @InjectMocks
    private RabbitMQService rabbitMQService;

    private MockedStatic<RabbitMQClient> rabbitMQClientMockedStatic;
    private MockedStatic<RabbitMQConsumerVerticle> rabbitMQConsumerVerticleMockedStatic;

    @BeforeEach
    public void setup() {
        rabbitMQClientMockedStatic = Mockito.mockStatic(RabbitMQClient.class);
        rabbitMQConsumerVerticleMockedStatic = Mockito.mockStatic(RabbitMQConsumerVerticle.class);
    }

    @Test
    public void testGetInstance() {
        RabbitMQService instance1 = RabbitMQService.getInstance(5);
        RabbitMQService instance2 = RabbitMQService.getInstance(10);

        assertSame(instance1, instance2);  // Singleton behavior: both instances should be the same
        assertEquals(5, instance1.getInstanceCount());  // The instance count should be the one passed initially
    }

    @Test
    public void testDeploySuccess() {
        when(config.getString(AppConfig.RABBITMQ_EXCHANGE_NAME)).thenReturn("exchange");
        when(rabbitMQClient.start()).thenReturn(Future.succeededFuture());
        when(rabbitMQClient.exchangeDeclare(any(), any(), anyBoolean(), anyBoolean()))
                .thenReturn(Future.succeededFuture());
        when(vertx.deployVerticle(any(), any(DeploymentOptions.class)))
                .thenReturn(Future.succeededFuture("deploymentID"));

        rabbitMQClientMockedStatic.when(() -> RabbitMQClient.create(any(), any(RabbitMQOptions.class)))
                .thenReturn(rabbitMQClient);

        Future<Boolean> future = rabbitMQService.deploy(vertx, config);

        assertTrue(future.succeeded());
        assertEquals(ServiceStatus.ACTIVE, rabbitMQService.getServiceStatus());
        verify(rabbitMQClient).start();
        verify(rabbitMQClient).exchangeDeclare(any(), any(), anyBoolean(), anyBoolean());
        verify(vertx).deployVerticle(any(), any(DeploymentOptions.class));
    }

    @Test
    public void testDeployFailureOnStart() {
        when(rabbitMQClient.start()).thenReturn(Future.failedFuture(new RuntimeException("Connection failed")));

        rabbitMQClientMockedStatic.when(() -> RabbitMQClient.create(any(), any(RabbitMQOptions.class)))
                .thenReturn(rabbitMQClient);

        Future<Boolean> future = rabbitMQService.deploy(vertx, config);

        assertTrue(future.failed());
        assertNotEquals(ServiceStatus.ACTIVE, rabbitMQService.getServiceStatus());
        verify(rabbitMQClient).start();
        verify(rabbitMQClient, never()).exchangeDeclare(any(), any(), anyBoolean(), anyBoolean());
    }

    @Test
    public void testDeployFailureOnExchangeDeclare() {
        when(config.getString(AppConfig.RABBITMQ_EXCHANGE_NAME)).thenReturn("exchange");
        when(rabbitMQClient.start()).thenReturn(Future.succeededFuture());
        when(rabbitMQClient.exchangeDeclare(any(), any(), anyBoolean(), anyBoolean()))
                .thenReturn(Future.failedFuture(new RuntimeException("Exchange declare failed")));

        rabbitMQClientMockedStatic.when(() -> RabbitMQClient.create(any(), any(RabbitMQOptions.class)))
                .thenReturn(rabbitMQClient);

        Future<Boolean> future = rabbitMQService.deploy(vertx, config);

        assertTrue(future.failed());
        assertNotEquals(ServiceStatus.ACTIVE, rabbitMQService.getServiceStatus());
        verify(rabbitMQClient).start();
        verify(rabbitMQClient).exchangeDeclare(any(), any(), anyBoolean(), anyBoolean());
    }

    @Test
    public void testGetServiceName() {
        assertEquals("RabbitMQ", rabbitMQService.getServiceName());
    }

    @Test
    public void testCreateRabbitMqOptions() {
        when(config.getString(AppConfig.RABBITMQ_HOST)).thenReturn("localhost");
        when(config.getString(AppConfig.RABBITMQ_USERNAME)).thenReturn("guest");
        when(config.getString(AppConfig.RABBITMQ_PASSWORD)).thenReturn("guest");
        when(config.getInteger(AppConfig.RABBITMQ_PORT)).thenReturn(5672);
        when(config.getInteger(AppConfig.RABBITMQ_RECOVERY_INTERVAL, 5000)).thenReturn(5000);
        when(config.getString(AppConfig.RABBITMQ_VHOST, null)).thenReturn("/");
        when(config.getBoolean(AppConfig.RABBITMQ_SSL_ENABLED)).thenReturn(true);

        RabbitMQOptions options = invokePrivateCreateRabbitMqOptions(config);

        assertEquals("localhost", options.getHost());
        assertEquals("guest", options.getUser());
        assertEquals("guest", options.getPassword());
        assertEquals(5672, options.getPort());
        assertEquals(5000, options.getNetworkRecoveryInterval());
        assertEquals("/", options.getVirtualHost());
        assertTrue(options.isSsl());
    }

    @Test
    public void testTeardownSuccess() {
        when(rabbitMQClient.isConnected()).thenReturn(true);
        when(rabbitMQClient.stop()).thenReturn(Future.succeededFuture());

        rabbitMQClientMockedStatic.when(() -> RabbitMQClient.create(any(), any(RabbitMQOptions.class)))
                .thenReturn(rabbitMQClient);

        rabbitMQService.deploy(vertx, config).result(); // initialize client

        Future<Void> future = rabbitMQService.teardown();

        assertTrue(future.succeeded());
        verify(rabbitMQClient).stop();
    }

    @Test
    public void testTeardownWithoutConnection() {
        when(rabbitMQClient.isConnected()).thenReturn(false);

        rabbitMQClientMockedStatic.when(() -> RabbitMQClient.create(any(), any(RabbitMQOptions.class)))
                .thenReturn(rabbitMQClient);

        rabbitMQService.deploy(vertx, config).result(); // initialize client

        Future<Void> future = rabbitMQService.teardown();

        assertTrue(future.succeeded());
        verify(rabbitMQClient, never()).stop();
    }

    @Test
    public void testCreateQueueAndDeployConsumer() {
        when(config.getString(AppConfig.RABBITMQ_QUEUE_NAME_PREFIX)).thenReturn("prefix");
        when(config.getString(AppConfig.RABBITMQ_EXCHANGE_NAME)).thenReturn("exchange");
        when(config.getString(AppConfig.RABBITMQ_SILO_HEADER_KEY)).thenReturn("silo");
        when(config.getString(AppConfig.RABBITMQ_QUEUES)).thenReturn("queue1;queue2");

        when(rabbitMQClient.queueDeclare(any(), anyBoolean(), anyBoolean(), anyBoolean()))
                .thenReturn(Future.succeededFuture());
        when(rabbitMQClient.queueBind(any(), any(), any(), any(Map.class)))
                .thenReturn(Future.succeededFuture());
        when(vertx.deployVerticle(any(), any(DeploymentOptions.class)))
                .thenReturn(Future.succeededFuture("deploymentID"));

        rabbitMQClientMockedStatic.when(() -> RabbitMQClient.create(any(), any(RabbitMQOptions.class)))
                .thenReturn(rabbitMQClient);

        List<Future<String>> futureList = rabbitMQService.createQueueAndDeployConsumer(vertx, config);

        assertEquals(2, futureList.size());
        futureList.forEach(future -> assertTrue(future.succeeded()));
        verify(rabbitMQClient, times(2)).queueDeclare(any(), anyBoolean(), anyBoolean(), anyBoolean());
        verify(rabbitMQClient, times(2)).queueBind(any(), any(), any(), any(Map.class));
        verify(vertx, times(2)).deployVerticle(any(), any(DeploymentOptions.class));
    }

    private RabbitMQOptions invokePrivateCreateRabbitMqOptions(JsonObject config) {
        try {
            var method = RabbitMQService.class.getDeclaredMethod("createRabbitMqOptions", JsonObject.class);
            method.setAccessible(true);
            return (RabbitMQOptions) method.invoke(rabbitMQService, config);
        } catch (Exception e) {
            fail("Failed to invoke private method createRabbitMqOptions");
            return null;
        }
    }
}

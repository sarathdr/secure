package com.usage.verticles;

import com.usage.common.Constants;
import com.usage.common.EventBusAddresses;
import com.usage.handlers.rest.RequestHandler;
import com.usage.handlers.rest.services.DbSignatureValidator;
import com.usage.handlers.rest.services.SignatureValidator;
import com.usage.utils.UsageDataMapper;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Handler;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.Message;
import io.vertx.core.json.JsonObject;
import io.vertx.core.tracing.TracingPolicy;
import io.vertx.jdbcclient.JDBCPool;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import java.util.Base64;
import java.util.List;

public class SyncMessageVerticle extends AbstractVerticle {
    private static final Logger LOG = LoggerFactory.getLogger(SyncMessageVerticle.class);

    private EventBus eventBus;
    private final SignatureValidator validator;

    private SyncMessageVerticle(final JDBCPool connectionPool) {
        validator = new DbSignatureValidator(connectionPool);
    }

    public static SyncMessageVerticle create(final JDBCPool connectionPool) {
        return new SyncMessageVerticle(connectionPool);
    }

    @Override
    public void start() throws Exception {
        super.start();
        eventBus = vertx.eventBus();
        eventBus.consumer(EventBusAddresses.PROCESS_SYNC_MESSAGE, processUsageData());
    }

    protected Handler<Message<Buffer>> processUsageData() {

        return (message) -> {
            final Buffer body = message.body();
            final JsonObject syncMessage = new JsonObject(body);
            final String correlationId = UsageDataMapper.getCorrelationId(syncMessage);

            MDC.put(Constants.CORRELATION_ID, correlationId);

            LOG.trace("Validating usage request");
            LOG.debug("Processing usage request: {}", correlationId);

            final byte[] signature = Base64
                    .getDecoder()
                    .decode(message.headers().get(RequestHandler.SIGNATURE_HEADER));

            final String tenantId = UsageDataMapper.getTenantId(syncMessage);
            final String instanceId = UsageDataMapper.getInstanceId(syncMessage);

            validator.validateSignature(tenantId, instanceId, signature, body.getBytes()).onSuccess(valid -> {
                if (!valid) {
                    LOG.debug("Invalid signature");
                    message.fail(400, "Invalid signature");
                    return;
                }

                final List<JsonObject> usageList = UsageDataMapper.map(syncMessage);
                if (!usageList.isEmpty()) {
                    eventBus.send(
                            EventBusAddresses.USAGE_REQUEST,
                            UsageDataMapper.convertLineOfStrings(usageList),
                            new DeliveryOptions()
                                    .setTracingPolicy(TracingPolicy.PROPAGATE)
                                    .addHeader(Constants.CORRELATION_ID, correlationId)
                    );
                } else {
                    LOG.warn("No usage data {}", syncMessage);
                }

                LOG.info("Number of processed messages {}", usageList.size());
                final var response = new JsonObject()
                        .put(Constants.CORRELATION_ID, correlationId)
                        .put(Constants.TENANT_ID, tenantId)
                        .put(Constants.INSTANCE_ID, instanceId)
                        .put(Constants.PROCESSED_USAGES, usageList.size());

                message.reply(response);

            }).onFailure(failed -> {
                LOG.warn("Failed to validate the message {}", failed.getMessage());
                message.fail(500, failed.getMessage());
            }).onComplete((result) -> {
                MDC.remove(Constants.CORRELATION_ID);
            });
        };
    }
}

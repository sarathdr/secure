package com.usage.handlers.rest.services;

import com.flexnet.lm.binary.PublisherIdentityRecord;
import com.flexnet.lm.signer.Signer;
import com.flexnet.lm.signer.SignerFactory;
import io.vertx.core.Future;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.sqlclient.Tuple;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DbSignatureValidator implements SignatureValidator {
    private static final Logger LOG = LoggerFactory.getLogger(DbSignatureValidator.class);

    private static final String SQL_TENANT_ID = "SELECT ID from LFS_TENANT where name = ?";
    private static final String SQL_SIG_ID = "SELECT PUBLISHER_SIGNATURE_ID from LFS_HOST where identifier = ? and TENANT_ID IN (" + SQL_TENANT_ID + " )";
    private static final String SQL_IDENTITY = "SELECT BACKOFFICE_IDENTITY from LFS_PUBLISHER_SIGNATURE where  ID IN(" + SQL_SIG_ID + ")";
    private static final String IDENTITY_COLUMN_NAME = "BACKOFFICE_IDENTITY";

    private final JDBCPool jdbcPool;

    private DbSignatureValidator(final JDBCPool pool) {
        jdbcPool = pool;
    }

    public static DbSignatureValidator create(final JDBCPool pool){
        return new DbSignatureValidator(pool);
    }

    @Override
    public Future<Boolean> validateSignature(final String tenantId, final String instanceId, byte[] signature, byte[] data) {
        return jdbcPool
                .preparedQuery(SQL_IDENTITY)
                .execute(Tuple.of(instanceId, tenantId))
                .compose(rows -> {
                    if (rows.size() == 0) {
                        return Future.succeededFuture(false);
                    }

                    final byte[] result = rows.iterator().next().getBuffer(IDENTITY_COLUMN_NAME).getBytes();
                    final PublisherIdentityRecord identity = new PublisherIdentityRecord();

                    try {
                        identity.parseAll(result);
                        identity.parse();

                        final Signer signer = SignerFactory.getInstance(identity, SignerFactory.SignatureType.CLIENT_SERVER);
                        signer.initVerify();
                        for (byte jsonByte : data) {
                            signer.update(jsonByte & 0xFF);
                        }

                        return Future.succeededFuture(signer.isSignatureValid(signature));
                    } catch (Exception e) {
                        LOG.error("Failed to read signature", e);
                        return Future.failedFuture(e);
                    }

                });
    }
}

import com.usage.common.AppConfig;
import com.usage.verticles.SyncMessageVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Future;
import io.vertx.core.Verticle;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.jdbcclient.JDBCPool;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.jupiter.api.extension.ExtendWith;

import java.util.function.Supplier;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class SyncMessageServiceTest {

    @Mock
    private Vertx vertx;

    @Mock
    private JsonObject config;

    @Mock
    private JDBCPool jdbcPool;

    @InjectMocks
    private SyncMessageService syncMessageService;

    private MockedStatic<JDBCPool> jdbcPoolMockedStatic;
    private MockedStatic<SyncMessageVerticle> syncMessageVerticleMockedStatic;

    @BeforeEach
    public void setup() {
        jdbcPoolMockedStatic = Mockito.mockStatic(JDBCPool.class);
        syncMessageVerticleMockedStatic = Mockito.mockStatic(SyncMessageVerticle.class);

        jdbcPoolMockedStatic.when(() -> JDBCPool.pool(any(Vertx.class), any(JsonObject.class)))
                .thenReturn(jdbcPool);
    }

    @Test
    public void testGetInstance() {
        SyncMessageService instance1 = SyncMessageService.getInstance(5);
        SyncMessageService instance2 = SyncMessageService.getInstance(10);

        assertSame(instance1, instance2);  // Singleton behavior: both instances should be the same
        assertEquals(5, instance1.getInstanceCount());  // The instance count should be the one passed initially
    }

    @Test
    public void testDeploySuccess() {
        when(vertx.deployVerticle(any(Supplier.class), any(DeploymentOptions.class)))
                .thenReturn(Future.succeededFuture("deploymentID"));

        syncMessageVerticleMockedStatic.when(() -> SyncMessageVerticle.create(any(JDBCPool.class)))
                .thenReturn(mock(SyncMessageVerticle.class));

        Future<Boolean> future = syncMessageService.deploy(vertx, config);

        assertTrue(future.succeeded());
        assertEquals(ServiceStatus.ACTIVE, syncMessageService.getServiceStatus());
        verify(vertx).deployVerticle(any(Supplier.class), any(DeploymentOptions.class));
        syncMessageVerticleMockedStatic.verify(() -> SyncMessageVerticle.create(any(JDBCPool.class)), times(1));
    }

    @Test
    public void testDeployFailure() {
        when(vertx.deployVerticle(any(Supplier.class), any(DeploymentOptions.class)))
                .thenReturn(Future.failedFuture(new RuntimeException("Deployment failed")));

        syncMessageVerticleMockedStatic.when(() -> SyncMessageVerticle.create(any(JDBCPool.class)))
                .thenReturn(mock(SyncMessageVerticle.class));

        Future<Boolean> future = syncMessageService.deploy(vertx, config);

        assertTrue(future.failed());
        assertNotEquals(ServiceStatus.ACTIVE, syncMessageService.getServiceStatus());
        verify(vertx).deployVerticle(any(Supplier.class), any(DeploymentOptions.class));
        syncMessageVerticleMockedStatic.verify(() -> SyncMessageVerticle.create(any(JDBCPool.class)), times(1));
    }

    @Test
    public void testCreateJdbcConnectionPool() {
        when(config.getString(AppConfig.DB_HOST)).thenReturn("localhost");
        when(config.getString(AppConfig.DB_PORT, "1433")).thenReturn("1433");
        when(config.getString(AppConfig.DB_NAME)).thenReturn("testdb");
        when(config.getBoolean(AppConfig.DB_ENCRYPT, false)).thenReturn(false);
        when(config.getString(AppConfig.DB_USERNAME)).thenReturn("user");
        when(config.getString(AppConfig.DB_PASSWORD)).thenReturn("pass");
        when(config.getInteger(AppConfig.DB_MAX_POOL_SIZE)).thenReturn(10);

        JDBCPool pool = invokePrivateCreateJdbcConnectionPool(vertx, config);

        assertNotNull(pool);
        verify(config).getString(AppConfig.DB_HOST);
        verify(config).getString(AppConfig.DB_PORT, "1433");
        verify(config).getString(AppConfig.DB_NAME);
        verify(config).getBoolean(AppConfig.DB_ENCRYPT, false);
        verify(config).getString(AppConfig.DB_USERNAME);
        verify(config).getString(AppConfig.DB_PASSWORD);
        verify(config).getInteger(AppConfig.DB_MAX_POOL_SIZE);
    }

    @Test
    public void testTeardownWithConnection() {
        when(jdbcPool.close()).thenReturn(Future.succeededFuture());

        syncMessageService.deploy(vertx, config).result(); // initialize pool

        Future<Void> future = syncMessageService.teardown();

        assertTrue(future.succeeded());
        verify(jdbcPool).close();
    }

    @Test
    public void testTeardownWithoutConnection() {
        Future<Void> future = syncMessageService.teardown();

        assertTrue(future.succeeded());
        verify(jdbcPool, never()).close();
    }

    @Test
    public void testGetServiceName() {
        assertEquals("SyncMessageProcessor", syncMessageService.getServiceName());
    }

    private JDBCPool invokePrivateCreateJdbcConnectionPool(Vertx vertx, JsonObject config) {
        try {
            var method = SyncMessageService.class.getDeclaredMethod("createJdbcConnectionPool", Vertx.class, JsonObject.class);
            method.setAccessible(true);
            return (JDBCPool) method.invoke(syncMessageService, vertx, config);
        } catch (Exception e) {
            fail("Failed to invoke private method createJdbcConnectionPool");
            return null;
        }
    }
}

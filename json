package com.usage.verticles;

import com.usage.annotations.ExcludeFromJacocoGeneratedReport;
import com.usage.common.AppConfig;
import com.usage.handlers.rest.UsageRequestHandler;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.json.JsonObject;
import io.vertx.core.tracing.TracingPolicy;
import io.vertx.ext.healthchecks.HealthCheckHandler;
import io.vertx.ext.healthchecks.Status;
import io.vertx.ext.web.Router;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.MessageFormat;

public class ServerVerticle extends AbstractVerticle {

    private static final Logger LOG = LoggerFactory.getLogger(ServerVerticle.class);
    private static final String DEFAULT_CONTEXT_ROUTE = "/usage";
    private static final String CONTEXT_ROUTE_PATTERN = "{0}/*";
    private static final int DEFAULT_PORT = 8080;

    private ServerVerticle() {
    }

    public static ServerVerticle create() {
        return new ServerVerticle();
    }

    @Override
    public void start(final Promise<Void> startPromise) {
        final Router router = setupRouter();
        final Integer port = config().getInteger(AppConfig.HTTP_PORT, DEFAULT_PORT);
        startServer(startPromise, router, port);
    }

    private Router setupRouter() {
        final Router restApiRouter = Router.router(vertx);
        final Router mainRouter = Router.router(vertx);
        final JsonObject config = config();

        //set context root
        final String contextRoute = MessageFormat.format(
                CONTEXT_ROUTE_PATTERN,
                config.getString(AppConfig.CONTEXT_ROUTE, DEFAULT_CONTEXT_ROUTE)
        );
        mainRouter.route(contextRoute).subRouter(restApiRouter);
        setUpHealthUrl(restApiRouter, config);

        UsageRequestHandler
                .create(vertx.eventBus())
                .registerHandlers(restApiRouter);

        return mainRouter;
    }

    private void setUpHealthUrl(final Router restApiRouter, final JsonObject config) {
        final JsonObject jsonObject = new JsonObject();
        jsonObject
                .put("version", config.getString(AppConfig.APP_VERSION, "unknown"))
                .put("buildDate", config.getString(AppConfig.BUILD_DATE, ""))
                .put("gitHash", config.getString(AppConfig.GIT_HASH, ""));


        final HealthCheckHandler healthCheckHandler = HealthCheckHandler.create(vertx);
        // Status can provide addition data provided as JSON
        healthCheckHandler.register("app", promise -> {
            promise.complete(Status.OK(jsonObject));
        });

        restApiRouter.get("/health").handler(healthCheckHandler);
    }

    private void startServer(Promise<Void> startPromise, Router router, Integer port) {
        final HttpServerOptions options = new HttpServerOptions().setLogActivity(true)
                .setTracingPolicy(TracingPolicy.PROPAGATE);
        vertx.createHttpServer(options)
                .requestHandler(router)
                .listen(port,
                        result -> handleServerStartResp(startPromise, port, result));
        LOG.debug("started verticle {} with id: {} ", ServerVerticle.class.getSimpleName(), deploymentID());
    }

    @ExcludeFromJacocoGeneratedReport
    private void handleServerStartResp(final Promise<Void> future,
                                       final Integer port,
                                       final AsyncResult<HttpServer> result) {
        if (result.succeeded()) {
            future.complete();
            LOG.info("Http server running on port: {}", port);
        } else {
            future.fail(result.cause());
        }
    }
}

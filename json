import com.usage.common.Constants;
import com.usage.common.EventBusAddresses;
import com.usage.utils.UsageDataMapper;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.json.JsonObject;
import io.vertx.core.tracing.TracingPolicy;
import io.vertx.junit5.VertxExtension;
import io.vertx.rabbitmq.RabbitMQClient;
import io.vertx.rabbitmq.RabbitMQConsumer;
import io.vertx.rabbitmq.RabbitMQMessage;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.slf4j.MDC;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(VertxExtension.class)
public class RabbitMQConsumerVerticleTest {

    @Mock
    private RabbitMQClient client;

    @Mock
    private RabbitMQConsumer consumer;

    @Mock
    private RabbitMQMessage rabbitMQMessage;

    @Mock
    private Vertx vertx;

    @Mock
    private UsageDataMapper usageDataMapper;

    private RabbitMQConsumerVerticle verticle;
    private final String queueName = "testQueue";

    @BeforeEach
    public void setup() {
        verticle = RabbitMQConsumerVerticle.create(client, queueName);
        verticle.init(vertx, vertx.getOrCreateContext());
    }

    @Test
    public void testStartSuccess(Promise<Void> startPromise) {
        when(client.basicConsumer(anyString())).thenReturn(Promise.<RabbitMQConsumer>promise().complete(consumer).future());

        verticle.start(startPromise);

        verify(client).basicConsumer(queueName);
        verify(consumer).handler(any());
        assertTrue(startPromise.future().succeeded());
    }

    @Test
    public void testStartFailure(Promise<Void> startPromise) {
        when(client.basicConsumer(anyString())).thenReturn(Promise.<RabbitMQConsumer>promise().fail("Failed").future());

        verticle.start(startPromise);

        verify(client).basicConsumer(queueName);
        assertTrue(startPromise.future().failed());
    }

    @Test
    public void testStopWhenConsumerIsInitialized(Promise<Void> stopPromise) {
        when(client.basicConsumer(anyString())).thenReturn(Promise.<RabbitMQConsumer>promise().complete(consumer).future());
        when(consumer.cancel()).thenReturn(Promise.<Void>promise().complete().future());

        verticle.start(Promise.promise()); // Initialize the consumer
        verticle.stop(stopPromise);

        verify(consumer).cancel();
        assertTrue(stopPromise.future().succeeded());
    }

    @Test
    public void testStopWhenConsumerIsNotInitialized(Promise<Void> stopPromise) {
        verticle.stop(stopPromise);
        verify(consumer, never()).cancel();
        assertTrue(stopPromise.future().succeeded());
    }

    @Test
    public void testMessageHandlerSuccess() {
        JsonObject jsonObject = new JsonObject().put("data", "value");
        when(rabbitMQMessage.body()).thenReturn(jsonObject.toBuffer());
        when(UsageDataMapper.getCorrelationId(any())).thenReturn("test-correlation-id");
        when(UsageDataMapper.map(any())).thenReturn(List.of(jsonObject));
        when(UsageDataMapper.convertLineOfStrings(any())).thenReturn("mappedString");

        ArgumentCaptor<String> addressCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> messageCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<DeliveryOptions> optionsCaptor = ArgumentCaptor.forClass(DeliveryOptions.class);

        verticle.messageHandler(rabbitMQMessage);

        verify(vertx.eventBus()).send(addressCaptor.capture(), messageCaptor.capture(), optionsCaptor.capture());
        assertEquals(EventBusAddresses.USAGE_REQUEST, addressCaptor.getValue());
        assertEquals("mappedString", messageCaptor.getValue());
        assertEquals("test-correlation-id", optionsCaptor.getValue().getHeaders().get(Constants.CORRELATION_ID));
    }

    @Test
    public void testMessageHandlerNoUsageData() {
        JsonObject jsonObject = new JsonObject();
        when(rabbitMQMessage.body()).thenReturn(jsonObject.toBuffer());
        when(UsageDataMapper.getCorrelationId(any())).thenReturn("test-correlation-id");
        when(UsageDataMapper.map(any())).thenReturn(List.of());

        verticle.messageHandler(rabbitMQMessage);

        verify(vertx.eventBus(), never()).send(anyString(), any(), any());
    }

    @Test
    public void testMessageHandlerExceptionHandling() {
        JsonObject jsonObject = new JsonObject().put("data", "value");
        when(rabbitMQMessage.body()).thenReturn(jsonObject.toBuffer());
        when(UsageDataMapper.getCorrelationId(any())).thenThrow(new RuntimeException("Test exception"));

        // This test ensures that the message handler doesn't propagate the exception
        assertDoesNotThrow(() -> verticle.messageHandler(rabbitMQMessage));

        // Verify that nothing was sent to the event bus
        verify(vertx.eventBus(), never()).send(anyString(), any(), any());
    }
}

package com.usage.verticles.services;

import com.usage.common.AppConfig;
import com.usage.verticles.SyncMessageVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Future;
import io.vertx.core.ThreadingModel;
import io.vertx.core.Verticle;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.jdbcclient.JDBCPool;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.MessageFormat;
import java.util.function.Supplier;

public class SyncMessageService extends DeployVerticleService {
    private static final Logger LOG = LoggerFactory.getLogger(SyncMessageService.class);
    private static final String SERVICE_NAME = "SyncMessageProcessor";
    private static final int WORKER_POOL_SIZE = 15;
    private static final String WORKER_POOL_NAME = "SyncMessageProcessorPool";
    private static final String JDBC_URL_PATTERN = "jdbc:sqlserver://{0}:{1};databaseName={2};encrypt={3}";
    private static final String DEFAULT_DB_PORT = "1433";
    private static SyncMessageService INSTANCE;

    private JDBCPool jdbcPool;

    private SyncMessageService(final int instances) {
        super(instances);
    }

    public static SyncMessageService getInstance(final int instances) {
        if (INSTANCE == null) {
            INSTANCE = new SyncMessageService(instances);
        }

        return INSTANCE;
    }

    private Supplier<Verticle> getVerticle(final Vertx vertx, final JsonObject jsonConfig) {
        // Single pool shared across verticles
        jdbcPool = createJdbcConnectionPool(vertx, jsonConfig);
        return () ->SyncMessageVerticle.create(jdbcPool);
    }

    @Override
    public Future<Boolean> deploy(final Vertx vertx, final JsonObject config) {
        return vertx.deployVerticle(getVerticle(vertx, config),
                new DeploymentOptions().setConfig(config)
                        .setThreadingModel(ThreadingModel.WORKER)
                        .setWorkerPoolName(WORKER_POOL_NAME)
                        .setWorkerPoolSize(WORKER_POOL_SIZE)
                        .setInstances(getInstanceCount())
        ).compose(
                result -> {
                    LOG.info("{} successfully deployed", getServiceName());
                    setStatus(ServiceStatus.ACTIVE);
                    return Future.succeededFuture(true);
                }
        );
    }


    @Override
    public String getServiceName() {
        return SERVICE_NAME;
    }

    private JDBCPool createJdbcConnectionPool(final Vertx vertx, final JsonObject jsonConfig) {
        final String connectionString = MessageFormat.format(
                JDBC_URL_PATTERN,
                jsonConfig.getString(AppConfig.DB_HOST),
                jsonConfig.getString(AppConfig.DB_PORT, DEFAULT_DB_PORT),
                jsonConfig.getString(AppConfig.DB_NAME),
                jsonConfig.getBoolean(AppConfig.DB_ENCRYPT, false)
        );

        LOG.debug("DB connection string {}", connectionString);

        final JsonObject config = new JsonObject()
                .put("url", connectionString)
                .put("user", jsonConfig.getString(AppConfig.DB_USERNAME))
                .put("password", jsonConfig.getString(AppConfig.DB_PASSWORD))
                .put("max_pool_size", jsonConfig.getInteger(AppConfig.DB_MAX_POOL_SIZE));

        return JDBCPool.pool(vertx, config);
    }

    @Override
    public Future<Void> teardown() {
        if (jdbcPool == null) {
            return super.teardown();
        }

        return jdbcPool.close();
    }
}

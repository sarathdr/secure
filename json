import com.usage.common.AppConfig;
import com.usage.common.Constants;
import com.usage.common.EventBusAddresses;
import com.usage.handlers.rest.RequestHandler;
import com.usage.handlers.rest.services.DbSignatureValidator;
import com.usage.utils.UsageDataMapper;
import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.Message;
import io.vertx.core.json.JsonObject;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.slf4j.MDC;

import java.util.Base64;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(VertxExtension.class)
public class SyncMessageVerticleIntegrationTest {

    @Mock
    private JDBCPool jdbcPool;

    @Mock
    private DbSignatureValidator validator;

    private SyncMessageVerticle syncMessageVerticle;

    @BeforeEach
    public void setup(Vertx vertx) {
        // Initialize the SyncMessageVerticle with a mocked JDBCPool
        syncMessageVerticle = SyncMessageVerticle.create(jdbcPool);
        syncMessageVerticle.init(vertx, vertx.getOrCreateContext());
    }

    @Test
    public void testProcessUsageDataSuccess(Vertx vertx, VertxTestContext testContext) {
        // Arrange
        EventBus eventBus = vertx.eventBus();
        JsonObject syncMessage = new JsonObject()
                .put(Constants.CORRELATION_ID, "test-correlation-id")
                .put(Constants.TENANT_ID, "test-tenant-id")
                .put(Constants.INSTANCE_ID, "test-instance-id");

        when(validator.validateSignature(anyString(), anyString(), any(byte[].class), any(byte[].class)))
                .thenReturn(io.vertx.core.Future.succeededFuture(true));

        vertx.deployVerticle(syncMessageVerticle, testContext.succeeding(id -> {
            // Act
            Buffer messageBody = Buffer.buffer(syncMessage.encode());
            eventBus.<JsonObject>request(EventBusAddresses.PROCESS_SYNC_MESSAGE, messageBody, new DeliveryOptions()
                    .addHeader(RequestHandler.SIGNATURE_HEADER, Base64.getEncoder().encodeToString("signature".getBytes())), reply -> {
                // Assert
                if (reply.succeeded()) {
                    JsonObject response = reply.result().body();
                    assertEquals("test-correlation-id", response.getString(Constants.CORRELATION_ID));
                    assertEquals("test-tenant-id", response.getString(Constants.TENANT_ID));
                    assertEquals("test-instance-id", response.getString(Constants.INSTANCE_ID));
                    testContext.completeNow();
                } else {
                    testContext.failNow(reply.cause());
                }
            });
        }));
    }

    @Test
    public void testProcessUsageDataInvalidSignature(Vertx vertx, VertxTestContext testContext) {
        // Arrange
        EventBus eventBus = vertx.eventBus();
        JsonObject syncMessage = new JsonObject()
                .put(Constants.CORRELATION_ID, "test-correlation-id")
                .put(Constants.TENANT_ID, "test-tenant-id")
                .put(Constants.INSTANCE_ID, "test-instance-id");

        when(validator.validateSignature(anyString(), anyString(), any(byte[].class), any(byte[].class)))
                .thenReturn(io.vertx.core.Future.succeededFuture(false));

        vertx.deployVerticle(syncMessageVerticle, testContext.succeeding(id -> {
            // Act
            Buffer messageBody = Buffer.buffer(syncMessage.encode());
            eventBus.<JsonObject>request(EventBusAddresses.PROCESS_SYNC_MESSAGE, messageBody, new DeliveryOptions()
                    .addHeader(RequestHandler.SIGNATURE_HEADER, Base64.getEncoder().encodeToString("signature".getBytes())), reply -> {
                // Assert
                if (reply.failed()) {
                    assertEquals(400, reply.cause().getMessage().contains("Invalid signature"));
                    testContext.completeNow();
                } else {
                    testContext.failNow(new AssertionError("Expected invalid signature failure"));
                }
            });
        }));
    }

    @Test
    public void testProcessUsageDataValidationFailure(Vertx vertx, VertxTestContext testContext) {
        // Arrange
        EventBus eventBus = vertx.eventBus();
        JsonObject syncMessage = new JsonObject()
                .put(Constants.CORRELATION_ID, "test-correlation-id")
                .put(Constants.TENANT_ID, "test-tenant-id")
                .put(Constants.INSTANCE_ID, "test-instance-id");

        when(validator.validateSignature(anyString(), anyString(), any(byte[].class), any(byte[].class)))
                .thenReturn(io.vertx.core.Future.failedFuture("Validation error"));

        vertx.deployVerticle(syncMessageVerticle, testContext.succeeding(id -> {
            // Act
            Buffer messageBody = Buffer.buffer(syncMessage.encode());
            eventBus.<JsonObject>request(EventBusAddresses.PROCESS_SYNC_MESSAGE, messageBody, new DeliveryOptions()
                    .addHeader(RequestHandler.SIGNATURE_HEADER, Base64.getEncoder().encodeToString("signature".getBytes())), reply -> {
                // Assert
                if (reply.failed()) {
                    assertTrue(reply.cause().getMessage().contains("Validation error"));
                    testContext.completeNow();
                } else {
                    testContext.failNow(new AssertionError("Expected validation failure"));
                }
            });
        }));
    }

    @Test
    public void testProcessUsageDataNoUsageData(Vertx vertx, VertxTestContext testContext) {
        // Arrange
        EventBus eventBus = vertx.eventBus();
        JsonObject syncMessage = new JsonObject()
                .put(Constants.CORRELATION_ID, "test-correlation-id")
                .put(Constants.TENANT_ID, "test-tenant-id")
                .put(Constants.INSTANCE_ID, "test-instance-id")
                .put("usages", new JsonObject()); // No usage data

        when(validator.validateSignature(anyString(), anyString(), any(byte[].class), any(byte[].class)))
                .thenReturn(io.vertx.core.Future.succeededFuture(true));

        vertx.deployVerticle(syncMessageVerticle, testContext.succeeding(id -> {
            // Act
            Buffer messageBody = Buffer.buffer(syncMessage.encode());
            eventBus.<JsonObject>request(EventBusAddresses.PROCESS_SYNC_MESSAGE, messageBody, new DeliveryOptions()
                    .addHeader(RequestHandler.SIGNATURE_HEADER, Base64.getEncoder().encodeToString("signature".getBytes())), reply -> {
                // Assert
                if (reply.succeeded()) {
                    JsonObject response = reply.result().body();
                    assertEquals("test-correlation-id", response.getString(Constants.CORRELATION_ID));
                    assertEquals("test-tenant-id", response.getString(Constants.TENANT_ID));
                    assertEquals("test-instance-id", response.getString(Constants.INSTANCE_ID));
                    assertEquals(0, response.getInteger(Constants.PROCESSED_USAGES));
                    testContext.completeNow();
                } else {
                    testContext.failNow(reply.cause());
                }
            });
        }));
    }
}

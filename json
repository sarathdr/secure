package com.usage.verticles;

import com.usage.common.Constants;
import com.usage.common.EventBusAddresses;
import com.usage.utils.UsageDataMapper;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.json.JsonObject;
import io.vertx.core.tracing.TracingPolicy;
import io.vertx.rabbitmq.RabbitMQClient;
import io.vertx.rabbitmq.RabbitMQConsumer;
import io.vertx.rabbitmq.RabbitMQMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import java.util.List;

public class RabbitMQConsumerVerticle extends AbstractVerticle {
    private static final Logger LOG = LoggerFactory.getLogger(RabbitMQConsumerVerticle.class);
    private final RabbitMQClient client;
    private final String queueName;

    private RabbitMQConsumer consumer;

    private RabbitMQConsumerVerticle(final RabbitMQClient client, final String queueName) {
        this.client = client;
        this.queueName = queueName;
    }

    public static RabbitMQConsumerVerticle create(final RabbitMQClient client, final String queueName) {
        return new RabbitMQConsumerVerticle(client, queueName);
    }

    @Override
    public void start(final Promise<Void> startPromise) {
        LOG.info("Starting consumer for the queue {}", queueName);

        client.basicConsumer(queueName).onSuccess(basicConsumer -> {
            consumer = basicConsumer;
            consumer.handler(this::messageHandler);
            startPromise.complete();
        }).onFailure(err -> {
            LOG.error("Unable start the consumer for the queue - " + this.queueName, err.getCause());
            startPromise.fail(err);
        });
    }

    private void messageHandler(final RabbitMQMessage rabbitMQMessage) {

        try {
            final JsonObject jsonObject = new JsonObject(rabbitMQMessage.body());
            final String correlationId = UsageDataMapper.getCorrelationId(jsonObject);

            MDC.put(Constants.CORRELATION_ID, correlationId);
            LOG.trace("Processing usage request");
            LOG.debug("Processing usage request: {}", correlationId);

            final List<JsonObject> usageList = UsageDataMapper.map(jsonObject);

            if (!usageList.isEmpty()) {
                vertx.eventBus().send(
                        EventBusAddresses.USAGE_REQUEST,
                        UsageDataMapper.convertLineOfStrings(usageList),
                        new DeliveryOptions()
                                .setTracingPolicy(TracingPolicy.PROPAGATE)
                                .addHeader(Constants.CORRELATION_ID, correlationId)
                );
            } else {
                LOG.warn("No usage data {}", jsonObject);
            }
        } catch (Exception e) {
            LOG.error("Usage processing failed! Reason: " + e.getMessage(), e);
        } finally {
            MDC.remove(Constants.CORRELATION_ID);
        }
    }

    @Override
    public void stop(final Promise<Void> stopPromise) {
        if (consumer != null) {
            consumer.cancel()
                    .onSuccess(result -> stopPromise.complete())
                    .onFailure(err -> {
                                LOG.error("Unable to stop the consumer - " + this.queueName, err.getCause());
                                stopPromise.fail(err);
                            }
                    );
        } else {
            stopPromise.complete();
        }
    }
}
